import functools

from . import native
from . import database

# -----------------------------------------------------------------------
# Hdf class
# -----------------------------------------------------------------------


class DataBase:
    """Class to read and delete data from a database generated by qupled"""

    # Read runs in the database
    @staticmethod
    def inspect_runs(database_name: str | None = None) -> dict:
        """Reads runs from the database and returns the content in the form of a dictionary.

        Args:
            database_name (str, optional): Name of the database to read from. Defaults to None.

        Returns:
            A dictionary whose keys are the run ids and values are the corresponding runs information.
        """
        db_handler = database.DataBaseHandler(database_name)
        return db_handler.inspect_runs()

    # Read runs in the database
    @staticmethod
    def read_run(
        run_id: int,
        database_name: str | None = None,
        input_names: list[str] | None = None,
        result_names: list[str] | None = None,
    ) -> dict:
        """
        Reads a run from the database.

        Args:
            run_id (int): The ID of the run to read.
            database_name (str | None, optional): The name of the database. Defaults to None.
            input_names (list[str] | None, optional): A list of input names to retrieve. Defaults to None.
            result_names (list[str] | None, optional): A list of result names to retrieve. Defaults to None.

        Returns:
            dict: A dictionary containing the run data.
        """
        db_handler = database.DataBaseHandler(database_name)
        return db_handler.get_run(run_id, input_names, result_names)

    # Read inputs in the database
    @staticmethod
    def read_inputs(
        run_id: int, database_name: str | None = None, names: list[str] | None = None
    ) -> dict:
        """Reads inputs from the database and returns the content in the form of a dictionary.

        Args:
            run_id: Identifier of the run to read input for.
            database_name: Name of the database to read from (default is None).
            names: A list of quantities to read (default is None, which reads all available quantities).

        Returns:
            A dictionary whose keys are the quantities listed in names and values are the corresponding inputs.
        """
        db_handler = database.DataBaseHandler(database_name)
        return db_handler.get_inputs(run_id, names if names is not None else [])

    # Read results in the database
    @staticmethod
    def read_results(
        run_id: int, database_name: str | None = None, names: list[str] | None = None
    ) -> dict:
        """Reads results from the database and returns the content in the form of a dictionary.

        Args:
            run_id: Identifier of the run to read results for.
            database_name: Name of the database to read from (default is None).
            names: A list of quantities to read (default is None, which reads all available quantities).

        Returns:
            A dictionary whose keys are the quantities listed in names and values are the corresponding results.
        """
        db_handler = database.DataBaseHandler(database_name)
        return db_handler.get_results(run_id, names)


# -----------------------------------------------------------------------
# MPI class
# -----------------------------------------------------------------------


class MPI:
    """Class to handle the calls to the MPI API"""

    def __init__(self):
        self.qp_mpi = native.MPI()

    def rank(self):
        """Get rank of the process"""
        return self.qp_mpi.rank()

    def is_root(self):
        """Check if the current process is root (rank 0)"""
        return self.qp_mpi.is_root()

    def barrier(self):
        """Setup an MPI barrier"""
        self.qp_mpi.barrier()

    def timer(self):
        """Get wall time"""
        return self.qp_mpi.timer()

    @staticmethod
    def run_only_on_root(func):
        """Python decorator for all methods that have to be run only by root"""

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            if MPI().is_root():
                return func(*args, **kwargs)

        return wrapper

    @staticmethod
    def synchronize_ranks(func):
        """Python decorator for all methods that need rank synchronization"""

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            func(*args, **kwargs)
            MPI().barrier()

        return wrapper

    @staticmethod
    def record_time(func):
        """Python decorator for all methods that have to be timed"""

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            mpi = MPI()
            tic = mpi.timer()
            func(*args, **kwargs)
            toc = mpi.timer()
            dt = toc - tic
            hours = dt // 3600
            minutes = (dt % 3600) // 60
            seconds = dt % 60
            if mpi.is_root():
                if hours > 0:
                    print("Elapsed time: %d h, %d m, %d s." % (hours, minutes, seconds))
                elif minutes > 0:
                    print("Elapsed time: %d m, %d s." % (minutes, seconds))
                else:
                    print("Elapsed time: %.1f s." % seconds)

        return wrapper
